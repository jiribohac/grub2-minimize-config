#!/bin/bash

# Install alternate scripts in /etc/grub.d to genarate a minimalist grub2 menu
#
# This is intended for people who know how to configure their bootloader,
# and want to customize the configuration.
#
# The default configuration, generated by the scripts shipped with grub in /etc/grub.d,
# is very generic and very complicated. It hurts to modify it by hand or use
# the resulting menu on a laggy serial console.
#
# This script creates an "orig/" subdirectory and moves the original scripts there
# It then installs minimalist scripts to genarate a minimalist menu.
# You may need to hand-tune the scripts to your specific needs (e.g. to load
# additional grub modules for your specific filesystem)
#
# An upgrade of the grub package may reinstall the original scripts.
# I am attempting to avoid this by creating empty files in place of the distribution
# scripts that are moved to orig/. However, this only works if your
# your distribution keeps modified versions of config files. 
# If not, you can partially fix the problem by re-running this script. 
# It will tell you wat to do.

[[ -d /etc/grub.d ]] || return
cp /etc/default/grub /etc/default/grub.orig
cat > /etc/default/grub <<EOF
# Beware, modified scripts in /etc/grub.d
# Only some settings usually found in this file are supported.
# To get the default grub setup, copy /etc/default/grub.orig to /etc/default/grub
# and /etc/grub.d/orig/* to /etc/grub.d

# don't use UUID for root= by default
GRUB_DISABLE_LINUX_UUID="true"

# specify kernel command line arguments using GRUB_CMDLINE_LINUX_DEFAULT.
# E. g. for serial console, do:
# GRUB_CMDLINE_LINUX_DEFAULT="console=tty0 console=ttyS0,115200"

# you can override GRUB_DEFAULT with grub2-once or grub2-set-default
GRUB_DEFAULT=0

GRUB_TIMEOUT=4
EOF

pushd /etc/grub.d >/dev/null

# if this script as been run already, just  check if an upgrade of the grub
# package hasn't recreated them

if [[ -d orig ]]; then
	# original scripts already moved to orig/
	pushd orig >/dev/null
	for i in *; do
		# this file has been deleted, nothing to do
		[[ -f "../$i" ]] || continue
		
		# this file is empty, nothing to do
		[[ `wc -c < "../$i"` == "0" ]] && continue

		# is it identical to the saved original? replace with an empty one
		if cmp -s "$i" "../$i"; then
			echo "replacing $i with an empty file" 
			rm "../$i"
			touch "../$i"
			continue
		fi

	done
	popd >/dev/null#orig

	if ls *.rpmnew *.dpkg* 2>/dev/null >/dev/null; then
		echo "These files may have been renamed by a grub upgrade. Please inspect and rename them manually:"
		ls -1 *.rpmnew *.dpkg*
	fi
	exit 0
fi

# this script has not been run yet
# create an orig/ directory and move all the scripts there
mkdir orig

GLOBIGNORE_old="$GLOBIGNORE"
GLOBIGNORE=README:orig
mv * orig
GLOBIGNORE="$GLOBIGNORE_old"

pushd orig >/dev/null
# prevent package upgrades from recreating the config files
# by creating empty files with identical names
for i in *; do touch "../$i"; done
popd >/dev/null #orig
	
cat > 00_header <<"_EOF"
#!/bin/sh

# default used if not specified in /etc/default/grub
GRUB_DEFAULT=${GRUB_DEFAULT:-0}
GRUB_TIMEOUT=${GRUB_TIMEOUT:-4}

# determine the grub file system containing the root directory
ROOT=`grub2-probe / --target=compatibility_hint`

cat <<EOF
# load modules; add other modules possibly needed by your system
insmod gzio
insmod part_gpt
insmod part_msdos
insmod ext2


# uncomment/adapt for grub serial console
#serial --unit 0 --speed=115200 
#terminal_input --append serial
#terminal_output --append serial

set root=${ROOT}
set default="${GRUB_DEFAULT}"
set timeout=${GRUB_TIMEOUT}

load_env
if [ "\${saved_entry}" ] ; then set default="\${saved_entry}"; fi
if [ "\${next_entry}" ] ; then set default="\${next_entry}"; set next_entry=; save_env next_entry; fi
EOF
_EOF
chmod a+x 00_header

cat > 10_linux <<"_EOF"
#! /bin/sh
# generate simplified menu items for installed linux kernels
# overrides the linux_entry function and calls the original script from the orig/ directory

set -e
# make it simple, really!
GRUB_DISABLE_SUBMENU=y
GRUB_DISABLE_RECOVERY=true

#override the function defined in orig/10_linux
function linux_entry () {
        os="$1"
        version="$2"
        type="$3"
        args="$4"

        if [ -n "${linux_root_device_thisversion}" ]; then
                root_device="root=${linux_root_device_thisversion}"
        else
                root_device=""
        fi

        echo "menuentry '$os - $basename' {"

        if [ -d /sys/firmware/efi ] && [ "x${GRUB_USE_LINUXEFI}" = "xtrue" ]; then
                echo -e "\tlinuxefi ${rel_dirname}/${basename} ${root_device} ${args}"
        else
                echo -e "\tlinux ${rel_dirname}/${basename} ${root_device} ${args}"
        fi
        if test -n "${initrd}" ; then
                if [ -d /sys/firmware/efi ] && [ "x${GRUB_USE_LINUXEFI}" = "xtrue" ]; then
                        echo -e "\tinitrdefi ${rel_dirname}/${initrd}"
                else
                        echo -e "\tinitrd ${rel_dirname}/${initrd}"
                fi
        fi
        echo "}"
}
readonly -f linux_entry
. /etc/grub.d/orig/10_linux
_EOF
	chmod a+x 10_linux


cat >40_custom <<"_EOF"
#!/bin/sh

# This is an example for adding custom menu items to your grub menu.
# Uncomment and adapt to your needs.
# If you want to place an entry before the autogenerated linux entries
# change the 40_ in the filename to a number between 01 and 09.

# Example custom linux entry
#cat << EOF
#menuentry 'custom linux menu entry'
#        linux   /boot/my-own-kernel
#        initrd  /boot/my-own-initrd
#}
#EOF

# Example of chainloading another bootloader (other OS from other disk/partition
#cat << EOF
#menuentry "Another OS on Disk 0, partition 3" {
#	insmod chain
#	chainloader (hd0,2)+1
#}
#EOF

_EOF
chmod a+x 40_custom
popd > /dev/null
